<?php 

/*
people_crm\core\Notice

Notice - Core Class for People_CRM Plugin
Last Updated 12 Jul 2019
-------------

Desription: - email and system messaging services are managed by this core class. 
	
	Determines who needs to be notified and how they need to be notified. Most often this will be via email, however sometimes, admin dashboard messages. Maybe sometimes it can be via both. 
	
	Notificaitons are different than Records in that they can be DYNAMICally updated after they are created to reflect "message" status, such as "sent", "delivered", "seen", "opened" depending on how a user interacts with the message and what information we collect from third-parties (email providers) about the status of the message. 
	
	
	Notice and Record typically work in tandem together. I've yet to discover (though I suspect there could be) a scenario where Notice is not called before Record is completed. Perhaps minor system-initiated checks that look for signs of inactivity or other changes in status? 
	
	Notifications are templatized which means that the whole message does not be reproduced everytime, only variables need to be stored in the notice. 
	
	
	5 Steps to sending templatized messages:
	- Figure out what message needs to be sent (because of the action that was taken)
	- Load message template 
		- If message template not available, don't send. 
	- What variables need to be set for the message
	- Set all available variables. 
		- Fill with defaults if not available. 
	- Send the message 
	
---
	Details on Sending Templatized Messages: 
		- Message Templates are CPT's set on each site where they are triggered. 
			- slug is the template name, which is used in calling, loading the template. 
		- Templates have shortcodes (or something similar) for variables following this pattern: [nb_m name] or [nb_m (var-name)]
			
	The process  of calling a template stuffed with shortcodes looks like this: 
	
	- Template is built first.
	- At run time,
		- an action is preformed that needs a notice sent. 
		- this class is called to initiate that process. 
		- Data is prsented from the action. 
		
		- then a template is called with shortcodes already set. 
			- In order for the short codes to be set, a function (get_message_vars) is then called that looks for the short code values. 
			- that same function (get_message_vars) then looks at the keys that were sent in the short code, pairs it with the data that was sent from the action, and then builds the notice. 
			- It also stores that paired data as part of the notice CPT for future reference. 
	
			
			- HOw do we know what variable need to be set?
				- We load the template content to work with, parse out shortcodes. 
				- Do we or should we pull dynamically? 
			- Dynamic, in so far as there is a master set of template variables that can be used, and the use of variables from the master class are open or optional. 

		// This is how to pull shortcodes from content to find all used variables. 
		// https://stackoverflow.com/questions/6290810/return-only-the-shortcode-from-post
		
			$pattern = get_shortcode_regex();
			preg_match('/'.$pattern.'/s', $post->post_content, $matches);
			if (is_array($matches) && $matches[2] == 'the_shortcode_name') {
			   // $shortcode = $matches[0];
			   // echo do_shortcode($shortcode);
			}	
			
			
			
	DataSets: 
		- There needs to be standarized datasets generated by all actions, or a way of categorizing all data that gets generated by the action performed in the system. 
		
		
		- Once a notice is built from template, that data from the variable extracted from the template will be what is stored in the notification data. 
	
		- Master Set of available template variables, stored in the options table? Maybe or just in the class. 

		Notice Template Slugs: 
			These are site specific. 
			
			What are the slugs for the notice templates? 
				- Some are dynamic, some are static
			- [user-type]_[service]_[action]_[detail]
			
			- admin_library_register_new
			- patron_library_register_new
			- patron_library_payment_new
			- patron_library_invoice_new
			- patron_library_invoice_voided
			- admin_library_account_inactive
			- admin_library_payment_new
			
			- patron_newletter_register
			- (etc.)
			
			
		Notice Shortcode Tags for [ nb_m  ]:
			
			What are the shortcode tags for notice templates? 
			
			- first_name
			- last_name
			- full_name
			- email
			- txn_date
			- txn_amount
			- txn_id
			- (etc.)
	
	NoticeTemplate class loads and prepares the NoticeTemplate.
	
	Building the list of Master Template Variables: 
		- Build a list of templates. 
			- What are the types of messages that will need to be sent? 
			
		- Extract Variables from those templates. 
			- That's your master list. 
	
	What does this return? 
	
---

Class Notice

	Variables: 
	- Type of notice: email, notice (dashboard), 
	- Recipient Type: user, admin, rep
		- Rep: (immediately assigned business representative)
			- Trainers
			- library supervisor
			- CRM sales rep
			- alumni rep
			- etc. 
	- Status
	- message_vars
	- Recipient ID
	- message_tmplt_id
	- content
	
	
	Functions: 
	
	- Send 
	
	- Send Email
	- Send Notice
	- Get 
	- build message
	- set_recipient_id
	- set_message_tmplt_id
	- save_message
	- update_message
	- get_message - if it already exsits (this is after the fact). 
	
	
	
	
	usage: 
		
		foreach( $notices as $message_slug ){
			
			$sender = new NNNotice( $notice_data );
			
			$result[] = $sender->send( $message_slug );
			
		}
		
	
	
*/

namespace people_crm\core;

use people_crm\core\sub\NNNoticeTemplate as Template;
use people_crm\core\sub\NNEmail as Email;

if ( ! defined( 'ABSPATH' ) ) { exit; }

if( !class_exists( 'Notice' ) ){
	class Notice{
		
		//Properties
		public 
			$notice_id = 0, //0 until saved in database. 
			$type = '', //email, notice (dashboard)
			$user_type = '', //user, admin, rep
			$patron = 0,
			$user_id = 0, //0 is for system
			$status = 'draft',
			$template_slug = '',
			$message_vars = array(),
			$subject = '',
			$content = '',
			$error = false;
			
		
		
		//Methods
		
			
		
	/*
		Name: __construct
		Description: 
	*/	
				
		
		public function __construct( $notice_data ){
			
			$this->init( $notice_data );
		}	
				
		
	/*
		Name: init
		Description: 
	*/	
				
		
		public function init( $data ){
			
			//What is the primary action of the incoming data? 
			//Set basic incoming data
			$this->set_data( $data );
			
			//if not NOTICE type of data, will need extra work. 
			if( $data[ 'action' ] !== 'notice' ){
				
				//So if action = receicpt, invoice, or registration. 			
				if( in_array( $data[ 'action' ], [ 'receipt', 'invoice', 'register' ] ) ){

					$this->type = 'email';
					$this->user_type = 'user';
					$this->user_id = $this->patron; //Patron should already be set. 
					$this->template_slug = $data[ 'action' ];
					$this->message_vars = $data;
					
				}
				
			}

			
			//What type of data is being received. Different for different 
			
				//If receipt, send receipt
				
				//If Invoice, Send invoice
				
				//If registration, send confirmation of registration
				
				//if Newsletter, send newsletter
				
				//if 
				
			
			
			
		}	
				
		
	/*
		Name: send
		Description: This is the initiating action for a message being sent from the notice class. 
	*/	
				
		
		public function send( ){
			
			$result = [];
			
			$result[ 'build_message' ] = $this->build_message();
			
			if( !( $this->error ) ){
				
				//If email, process this first. 
				if( $this->type == 'email' )
					$result[ 'send_email' ] = $this->send_email();
				
				//Save after an email has been sent. 
				$result[ 'save_notice' ] = $this->save_notice();
				
				//if notice, point to the save notice which was processed first. 
				if( $this->type == 'notice' )
					$result[ 'send_notice' ] = $this->send_notice();				
			}
			
			return $result;
			//result of the message send. Be verbose; this get's recorded for reference purposes. 	
		}	
			
		
	/*
		Name: set_data
		Description: This receives initiating data so that a message can be successfully sent. Recieves only that data which is necessary for sending messages. 
		
	*/	
				
		
		public function set_data( $data ){
			
			foreach ( get_object_vars( $this ) as $key => $value ){
				if( isset( $data[ $key ] ) && !empty( $data[ $key ] ) ){
					$this->$key = $data[ $key ];
				} elseif( isset( $data[ 'notice' ][ $key ] ) && !empty( $data[ 'notice' ][ $key ] )  ){
					$this->$key = $data[ 'notice' ][ $key ];
				}
			}	
			
			
			
				/*
			$type = '',
			$user_type = '',
			$patron_id = 0,
			$user_id = 0, //0 is for system
			$status = '',
			$message_tmplt_id = '',
			$message_vars = array(),
			$content = '';
				
				*/
			
			
		}	
				
		
	/*
		Name: send_email
		Description: This takes the finalized content and sends it to the requested recipient. 
	*/	
				
		
		public function send_email(){
			
			$data = array(
			
				'user_id' => $this->user_id, //who is the recipient?
				//'from' => '', 
				'subject' => $this->subject,
				'message' => $this->content,
				'html' => true,
				'headers' => [] //does anyone need a cc or bcc?
				
			);
			
			$email = new Email( $data );
			
			if( !$email->error )
				$result[ __METHOD__ ] = $email->send();
			
			return $result; //
			
		}	
				
		
	/*
		Name: send_notice
		Description: This is nothing more than a reference to the Notice CPT in the CRM. But this will toggle a setting that marks it as an active read. 
		
		Maybe or this is a notice's default state based on the user_id. If user_id remains 0, and an email is not sent. then it only get's posted to the system. 
		
		params: 
			message_id
			patron_id
		
	*/	
				
		
		public function send_notice(){
			
			//What settings need to be set to make this visble in the system?
			//The notice is saved to the database automatically. 
			
			//It's a matter of flagging a users account. 
			//Set a user_meta property_exists
			
			/*
			add to user meta = nn_notices which simply holds a key/value set message_id => status
			update_usermeta( recepient_id, message_id,  )
			
			or we flag the message as unread by admin in the post_meta. 
			
			*/
			
			return true;
		}	
				

				
		
	/*
		Name: build_message
		Description: 
	*/	
				
		
		public function build_message(){
			
			$template = new Template( $this->template_slug );
			
			
			if( !$template->error ){
				
				$template->prepare( $this->message_vars );
				
				$this->subject = $template->get_subject();
				
				$this->content = $template->get_content();
				
			} else {
				
				//template not found. 
				$error = new \WP_Error( 'message template not found.' );
				//dump( __LINE__, __METHOD__, $error );
				
				return $error;
			}
			
			return true; 
		}	

		
	/*
		Name: get_notice
		Description: This calls notice from database. Not sure how this is referenced for such a call. YOu would need a notice ID.
	*/	
				
		
		public function get_notice(){
			
			
			
		}	
		

		
	/*
		Name: save_notice
		Description: Save notice to CPT for CRM. 
	*/	
				
		
		public function save_notice(){		
			
			if( $this->status == 'draft' )
				$this->status = 'posted';
			
			
			//Waht needs to be set for a save_post?
			$post_arr = [
				'post_author' => $this->patron,
				'post_date' => '',
				'post_content' => $this->content,
				'post_title' => $this->subject,
				'post_status' => $this->status,
				'post_type' => NN_PREFIX.'notice',
				'post_parent' => $this->get_tempalte_id(), //incomplete try get_page_by_path() ,
			];
			
			
			
			//Array_filter drops empty fields if no callback function is provided. 
			$post_arr = array_filter( $post_arr /*,$callback_function missing*/ );
			
			//Has this post already been inserted? 
			//Setup to assess if post exists:
			foreach( [ 'title', 'content', 'date' ] as $exists ) 
				$$exists = $post_arr[ "post_$exists" ];
			
			//Now we're checking if post exists. 
			if( post_exists( $title, $content, $date ) === 0 ){//It doesn't exists
			
				//dump( __LINE__, __METHOD__, $this->post_arr );

				//This information is stored in the CRM/MasterSite
				nn_switch_to_base_blog();
				
				$result = wp_insert_post( $post_arr );
				
				//Return back to current space. 
				nn_return_from_base_blog();
			
				if( !is_wp_error( $result ) ){
					
					$this->ID = $result;
					return true;
				}
				
				return $result;
				
			}
			
			return false;
			
			
		}	
				
	/*
		Name: update_notice
		Description: 
	*/	
				
		
		public function update_notice(){
			
			
		}	
				
	/*
		Name: get_tempalte_id
		Description: Get the ID of the email template used to create the message. This will be assigned as the 'post_parent' ID. 
	*/	
				
		
		public function get_tempalte_id(){
			
			$template = get_page_by_path( $this->tempalte_slug, OBJECT, 'nnnoticetemplate' );
			
			return ( $template )? $template->ID : 0 ;
			
		}		
				
	/*
		Name: 
		Description: 
	*/	
				
		
		public function __(){
			
			
		}	
		
	}
}
	
	
?>
	
	
	